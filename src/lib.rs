/// Automatically generated by the FlatBuffers compiler
pub extern crate flatbuffers;

mod zkinterface_generated;
use zkinterface_generated::zkinterface as fb;
use std::io::Read;
use std::fmt;
use std::fs::File;

#[derive(Debug)]
pub struct FlatError {
    details: String
}

impl FlatError {
    fn new(msg: &str) -> FlatError {
        FlatError{details: msg.to_string()}
    }

}

impl fmt::Display for FlatError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f,"{}",self.details)
    }
}

impl std::error::Error for FlatError {
    fn description(&self) -> &str {
        &self.details
    }
}

pub type Result<T> = std::result::Result<T,FlatError>;

impl From<std::io::Error> for FlatError {
    fn from(error: std::io::Error) -> Self {
        let msg = format!("{}", error);
        FlatError::new(&msg)
    }
}

pub fn read_constraint_system<'a>(b: &'a Vec<u8>)-> Result<fb::ConstraintSystem<'a>> {
    let root = fb::get_root_as_root(&b);
    root.message_as_constraint_system().
        ok_or(FlatError::new("Input file is not a flatbuffer Constraint System"))
}

pub fn read_circuit_header<'a>(b: &'a Vec<u8>)-> Result<fb::CircuitHeader<'a>> {
    let root = fb::get_root_as_root(&b);
    root.message_as_circuit_header().
        ok_or(FlatError::new("Input file is not a flatbuffer Circuit Header"))
}

pub fn read_witnesses<'a>(b: &'a Vec<u8>)-> Result<fb::Witness<'a>> {
    let root = fb::get_root_as_root(&b);
    root.message_as_witness().
        ok_or(FlatError::new("Input file is not a flatbuffer Witness"))
}
#[derive(Debug)]
struct Variable {
    id: usize,
    value: [u8; 32]
}

fn get_variables<'a>(fbvs: fb::Variables<'a>) -> Vec<Variable> {
    let var_ids = fbvs.variable_ids().unwrap();
    let values = fbvs.values().unwrap();

    let num_vars = var_ids.len();

    // To return
    let mut vs = Vec::new();

    if num_vars == 0 {
        return Vec::new();
    }
    let ba_len = values.len() / num_vars;

    for i in 0..num_vars {
        let mut val = [0; 32];
        val[..ba_len].clone_from_slice(&values[i*ba_len..(i+1)*ba_len]);
        let v = Variable { id: var_ids.get(i) as usize, value: val };
        vs.push(v);
    }

    vs
}

#[test]
fn test_reading() {
    // Read circuit header, includes inputs
    let mut fh = File::open("foo.inp.zkif").unwrap();
    let mut bufh = Vec::new();
    fh.read_to_end(&mut bufh).unwrap();
    let header = read_circuit_header(&bufh).unwrap();

    // Read constraint system
    let mut fcs = File::open("foo.zkif").unwrap();
    let mut bufcs = Vec::new();
    fcs.read_to_end(&mut bufcs).unwrap();
    let cs = read_constraint_system(&bufcs).unwrap();

    let constraints = cs.constraints().unwrap();
    let num_constraints = constraints.len();
    let variables = header.instance_variables().unwrap();
    let vs = get_variables(variables);
    println!("Variables: {:?}\n", vs);

    for ctr in cs.constraints().unwrap() {
      println!("a: {:?}\n", get_variables(ctr.linear_combination_a().unwrap()));
      println!("b: {:?}\n", get_variables(ctr.linear_combination_b().unwrap()));
      println!("c: {:?}\n", get_variables(ctr.linear_combination_c().unwrap()));
    }
}
