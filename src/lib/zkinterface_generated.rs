// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod zkinterface {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MESSAGE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MESSAGE: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE: [Message; 5] = [
  Message::NONE,
  Message::CircuitHeader,
  Message::ConstraintSystem,
  Message::Witness,
  Message::Command,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Message(pub u8);
#[allow(non_upper_case_globals)]
impl Message {
  pub const NONE: Self = Self(0);
  pub const CircuitHeader: Self = Self(1);
  pub const ConstraintSystem: Self = Self(2);
  pub const Witness: Self = Self(3);
  pub const Command: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::CircuitHeader,
    Self::ConstraintSystem,
    Self::Witness,
    Self::Command,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::CircuitHeader => Some("CircuitHeader"),
      Self::ConstraintSystem => Some("ConstraintSystem"),
      Self::Witness => Some("Witness"),
      Self::Command => Some("Command"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Message {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Message {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Message {
    type Output = Message;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Message {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Message {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Message {}
pub struct MessageUnionTableOffset {}

pub enum CircuitHeaderOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A description of a circuit or sub-circuit.
/// This can be a complete circuit ready for proving,
/// or a part of a circuit being built.
pub struct CircuitHeader<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CircuitHeader<'a> {
  type Inner = CircuitHeader<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CircuitHeader<'a> {
  pub const VT_INSTANCE_VARIABLES: flatbuffers::VOffsetT = 4;
  pub const VT_FREE_VARIABLE_ID: flatbuffers::VOffsetT = 6;
  pub const VT_FIELD_MAXIMUM: flatbuffers::VOffsetT = 8;
  pub const VT_CONFIGURATION: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CircuitHeader { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CircuitHeaderArgs<'args>
  ) -> flatbuffers::WIPOffset<CircuitHeader<'bldr>> {
    let mut builder = CircuitHeaderBuilder::new(_fbb);
    builder.add_free_variable_id(args.free_variable_id);
    if let Some(x) = args.configuration { builder.add_configuration(x); }
    if let Some(x) = args.field_maximum { builder.add_field_maximum(x); }
    if let Some(x) = args.instance_variables { builder.add_instance_variables(x); }
    builder.finish()
  }


  /// Instance variables. This is also called public inputs to the circuit.
  ///
  /// - Variables are allocated by the sender of this message.
  /// - The same structure must be provided for R1CS and witness generations.
  /// - Values may be omitted in some contexts, such as in a preprocessing phase.
  /// - During witness generation, variables must be assigned values.
  /// - In the particular context of a gadget call, `instance_variables` holds the inputs
  ///   to the gadget, i.e. variables allocated by the caller that the gadget can
  ///   refer to. In the context of a gadget response, it holds the outputs of the gadget,
  ///   i.e. variables allocated by the gadget that the caller can refer to.
  #[inline]
  pub fn instance_variables(&self) -> Option<Variables<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Variables>>(CircuitHeader::VT_INSTANCE_VARIABLES, None)}
  }
  /// A variable ID greater than all IDs allocated by the sender of this message.
  /// The recipient of this message can allocate new IDs >= free_variable_id.
  #[inline]
  pub fn free_variable_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(CircuitHeader::VT_FREE_VARIABLE_ID, Some(0)).unwrap()}
  }
  /// The largest element of the finite field used by the current system.
  /// A canonical little-endian representation of the field order minus one.
  /// See `Variables.values` below.
  #[inline]
  pub fn field_maximum(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CircuitHeader::VT_FIELD_MAXIMUM, None)}
  }
  /// Optional: Any custom parameter that may influence the circuit construction.
  ///
  /// Example: function_name, if a gadget supports multiple function variants.
  /// Example: the depth of a Merkle tree.
  /// Counter-example: a Merkle path is not config and belongs in `instance_variables.info`.
  #[inline]
  pub fn configuration(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue>>>>(CircuitHeader::VT_CONFIGURATION, None)}
  }
}

impl flatbuffers::Verifiable for CircuitHeader<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Variables>>("instance_variables", Self::VT_INSTANCE_VARIABLES, false)?
     .visit_field::<u64>("free_variable_id", Self::VT_FREE_VARIABLE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("field_maximum", Self::VT_FIELD_MAXIMUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValue>>>>("configuration", Self::VT_CONFIGURATION, false)?
     .finish();
    Ok(())
  }
}
pub struct CircuitHeaderArgs<'a> {
    pub instance_variables: Option<flatbuffers::WIPOffset<Variables<'a>>>,
    pub free_variable_id: u64,
    pub field_maximum: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub configuration: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>,
}
impl<'a> Default for CircuitHeaderArgs<'a> {
  #[inline]
  fn default() -> Self {
    CircuitHeaderArgs {
      instance_variables: None,
      free_variable_id: 0,
      field_maximum: None,
      configuration: None,
    }
  }
}

pub struct CircuitHeaderBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CircuitHeaderBuilder<'a, 'b> {
  #[inline]
  pub fn add_instance_variables(&mut self, instance_variables: flatbuffers::WIPOffset<Variables<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Variables>>(CircuitHeader::VT_INSTANCE_VARIABLES, instance_variables);
  }
  #[inline]
  pub fn add_free_variable_id(&mut self, free_variable_id: u64) {
    self.fbb_.push_slot::<u64>(CircuitHeader::VT_FREE_VARIABLE_ID, free_variable_id, 0);
  }
  #[inline]
  pub fn add_field_maximum(&mut self, field_maximum: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CircuitHeader::VT_FIELD_MAXIMUM, field_maximum);
  }
  #[inline]
  pub fn add_configuration(&mut self, configuration: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CircuitHeader::VT_CONFIGURATION, configuration);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CircuitHeaderBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CircuitHeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CircuitHeader<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CircuitHeader<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CircuitHeader");
      ds.field("instance_variables", &self.instance_variables());
      ds.field("free_variable_id", &self.free_variable_id());
      ds.field("field_maximum", &self.field_maximum());
      ds.field("configuration", &self.configuration());
      ds.finish()
  }
}
pub enum ConstraintSystemOffset {}
#[derive(Copy, Clone, PartialEq)]

/// ConstraintSystem represents constraints to be added to the constraint system.
///
/// Multiple such messages are equivalent to the concatenation of `constraints` arrays.
pub struct ConstraintSystem<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConstraintSystem<'a> {
  type Inner = ConstraintSystem<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ConstraintSystem<'a> {
  pub const VT_CONSTRAINTS: flatbuffers::VOffsetT = 4;
  pub const VT_INFO: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ConstraintSystem { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ConstraintSystemArgs<'args>
  ) -> flatbuffers::WIPOffset<ConstraintSystem<'bldr>> {
    let mut builder = ConstraintSystemBuilder::new(_fbb);
    if let Some(x) = args.info { builder.add_info(x); }
    if let Some(x) = args.constraints { builder.add_constraints(x); }
    builder.finish()
  }


  #[inline]
  pub fn constraints(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BilinearConstraint<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BilinearConstraint>>>>(ConstraintSystem::VT_CONSTRAINTS, None)}
  }
  /// Optional: Any complementary info that may be useful.
  ///
  /// Example: human-readable descriptions.
  /// Example: custom hints to an optimizer or analyzer.
  #[inline]
  pub fn info(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue>>>>(ConstraintSystem::VT_INFO, None)}
  }
}

impl flatbuffers::Verifiable for ConstraintSystem<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BilinearConstraint>>>>("constraints", Self::VT_CONSTRAINTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValue>>>>("info", Self::VT_INFO, false)?
     .finish();
    Ok(())
  }
}
pub struct ConstraintSystemArgs<'a> {
    pub constraints: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BilinearConstraint<'a>>>>>,
    pub info: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>,
}
impl<'a> Default for ConstraintSystemArgs<'a> {
  #[inline]
  fn default() -> Self {
    ConstraintSystemArgs {
      constraints: None,
      info: None,
    }
  }
}

pub struct ConstraintSystemBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConstraintSystemBuilder<'a, 'b> {
  #[inline]
  pub fn add_constraints(&mut self, constraints: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BilinearConstraint<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstraintSystem::VT_CONSTRAINTS, constraints);
  }
  #[inline]
  pub fn add_info(&mut self, info: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstraintSystem::VT_INFO, info);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConstraintSystemBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConstraintSystemBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConstraintSystem<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ConstraintSystem<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ConstraintSystem");
      ds.field("constraints", &self.constraints());
      ds.field("info", &self.info());
      ds.finish()
  }
}
pub enum WitnessOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Witness represents an assignment of values to variables.
///
/// - Does not include variables already given in `CircuitHeader.instance_variables`.
/// - Does not include the constant one variable.
/// - Multiple such messages are equivalent to the concatenation of `Variables` arrays.
pub struct Witness<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Witness<'a> {
  type Inner = Witness<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Witness<'a> {
  pub const VT_ASSIGNED_VARIABLES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Witness { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args WitnessArgs<'args>
  ) -> flatbuffers::WIPOffset<Witness<'bldr>> {
    let mut builder = WitnessBuilder::new(_fbb);
    if let Some(x) = args.assigned_variables { builder.add_assigned_variables(x); }
    builder.finish()
  }


  #[inline]
  pub fn assigned_variables(&self) -> Option<Variables<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Variables>>(Witness::VT_ASSIGNED_VARIABLES, None)}
  }
}

impl flatbuffers::Verifiable for Witness<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Variables>>("assigned_variables", Self::VT_ASSIGNED_VARIABLES, false)?
     .finish();
    Ok(())
  }
}
pub struct WitnessArgs<'a> {
    pub assigned_variables: Option<flatbuffers::WIPOffset<Variables<'a>>>,
}
impl<'a> Default for WitnessArgs<'a> {
  #[inline]
  fn default() -> Self {
    WitnessArgs {
      assigned_variables: None,
    }
  }
}

pub struct WitnessBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WitnessBuilder<'a, 'b> {
  #[inline]
  pub fn add_assigned_variables(&mut self, assigned_variables: flatbuffers::WIPOffset<Variables<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Variables>>(Witness::VT_ASSIGNED_VARIABLES, assigned_variables);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WitnessBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WitnessBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Witness<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Witness<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Witness");
      ds.field("assigned_variables", &self.assigned_variables());
      ds.finish()
  }
}
pub enum CommandOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Optional: Command messages can be used to request actions from the receiver. This makes it
/// possible to write code that works in different environments. Commands and parameters
/// can be passed over the same byte stream as other messages; if so Command must be the first
/// message. This reduces the need for environment-specific methods (it can replace CLI --flags, etc).
pub struct Command<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Command<'a> {
  type Inner = Command<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Command<'a> {
  pub const VT_CONSTRAINTS_GENERATION: flatbuffers::VOffsetT = 4;
  pub const VT_WITNESS_GENERATION: flatbuffers::VOffsetT = 6;
  pub const VT_PARAMETERS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Command { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CommandArgs<'args>
  ) -> flatbuffers::WIPOffset<Command<'bldr>> {
    let mut builder = CommandBuilder::new(_fbb);
    if let Some(x) = args.parameters { builder.add_parameters(x); }
    builder.add_witness_generation(args.witness_generation);
    builder.add_constraints_generation(args.constraints_generation);
    builder.finish()
  }


  /// For gadget flows.
  /// Request the generation of a constraint system (or part thereof).
  /// If true, this must be followed by a CircuitHeader.
  /// The response must be another CircuitHeader message with a greater `free_variable_id`
  /// followed by one or more ConstraintSystem messages.
  #[inline]
  pub fn constraints_generation(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Command::VT_CONSTRAINTS_GENERATION, Some(false)).unwrap()}
  }
  /// For gadget flows.
  /// Request the generation of a witness (or part thereof).
  /// If true, this must be followed by a CircuitHeader, and the `instance_variables`
  /// variables must contain input values.
  /// The response must be another CircuitHeader message, with a greater `free_variable_id`,
  /// with output values in `instance_variables`, followed by one or more `Witness` messages.
  #[inline]
  pub fn witness_generation(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Command::VT_WITNESS_GENERATION, Some(false)).unwrap()}
  }
  /// Optional: Any complementary parameter that may be useful.
  #[inline]
  pub fn parameters(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue>>>>(Command::VT_PARAMETERS, None)}
  }
}

impl flatbuffers::Verifiable for Command<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("constraints_generation", Self::VT_CONSTRAINTS_GENERATION, false)?
     .visit_field::<bool>("witness_generation", Self::VT_WITNESS_GENERATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValue>>>>("parameters", Self::VT_PARAMETERS, false)?
     .finish();
    Ok(())
  }
}
pub struct CommandArgs<'a> {
    pub constraints_generation: bool,
    pub witness_generation: bool,
    pub parameters: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>,
}
impl<'a> Default for CommandArgs<'a> {
  #[inline]
  fn default() -> Self {
    CommandArgs {
      constraints_generation: false,
      witness_generation: false,
      parameters: None,
    }
  }
}

pub struct CommandBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CommandBuilder<'a, 'b> {
  #[inline]
  pub fn add_constraints_generation(&mut self, constraints_generation: bool) {
    self.fbb_.push_slot::<bool>(Command::VT_CONSTRAINTS_GENERATION, constraints_generation, false);
  }
  #[inline]
  pub fn add_witness_generation(&mut self, witness_generation: bool) {
    self.fbb_.push_slot::<bool>(Command::VT_WITNESS_GENERATION, witness_generation, false);
  }
  #[inline]
  pub fn add_parameters(&mut self, parameters: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Command::VT_PARAMETERS, parameters);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CommandBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CommandBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Command<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Command<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Command");
      ds.field("constraints_generation", &self.constraints_generation());
      ds.field("witness_generation", &self.witness_generation());
      ds.field("parameters", &self.parameters());
      ds.finish()
  }
}
pub enum BilinearConstraintOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A single R1CS constraint between variables.
///
/// - Represents the linear combinations of variables A, B, C such that:
///       (A) * (B) = (C)
/// - A linear combination is given as a sequence of (variable ID, coefficient).
pub struct BilinearConstraint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BilinearConstraint<'a> {
  type Inner = BilinearConstraint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BilinearConstraint<'a> {
  pub const VT_LINEAR_COMBINATION_A: flatbuffers::VOffsetT = 4;
  pub const VT_LINEAR_COMBINATION_B: flatbuffers::VOffsetT = 6;
  pub const VT_LINEAR_COMBINATION_C: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BilinearConstraint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BilinearConstraintArgs<'args>
  ) -> flatbuffers::WIPOffset<BilinearConstraint<'bldr>> {
    let mut builder = BilinearConstraintBuilder::new(_fbb);
    if let Some(x) = args.linear_combination_c { builder.add_linear_combination_c(x); }
    if let Some(x) = args.linear_combination_b { builder.add_linear_combination_b(x); }
    if let Some(x) = args.linear_combination_a { builder.add_linear_combination_a(x); }
    builder.finish()
  }


  #[inline]
  pub fn linear_combination_a(&self) -> Option<Variables<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Variables>>(BilinearConstraint::VT_LINEAR_COMBINATION_A, None)}
  }
  #[inline]
  pub fn linear_combination_b(&self) -> Option<Variables<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Variables>>(BilinearConstraint::VT_LINEAR_COMBINATION_B, None)}
  }
  #[inline]
  pub fn linear_combination_c(&self) -> Option<Variables<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Variables>>(BilinearConstraint::VT_LINEAR_COMBINATION_C, None)}
  }
}

impl flatbuffers::Verifiable for BilinearConstraint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Variables>>("linear_combination_a", Self::VT_LINEAR_COMBINATION_A, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Variables>>("linear_combination_b", Self::VT_LINEAR_COMBINATION_B, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Variables>>("linear_combination_c", Self::VT_LINEAR_COMBINATION_C, false)?
     .finish();
    Ok(())
  }
}
pub struct BilinearConstraintArgs<'a> {
    pub linear_combination_a: Option<flatbuffers::WIPOffset<Variables<'a>>>,
    pub linear_combination_b: Option<flatbuffers::WIPOffset<Variables<'a>>>,
    pub linear_combination_c: Option<flatbuffers::WIPOffset<Variables<'a>>>,
}
impl<'a> Default for BilinearConstraintArgs<'a> {
  #[inline]
  fn default() -> Self {
    BilinearConstraintArgs {
      linear_combination_a: None,
      linear_combination_b: None,
      linear_combination_c: None,
    }
  }
}

pub struct BilinearConstraintBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BilinearConstraintBuilder<'a, 'b> {
  #[inline]
  pub fn add_linear_combination_a(&mut self, linear_combination_a: flatbuffers::WIPOffset<Variables<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Variables>>(BilinearConstraint::VT_LINEAR_COMBINATION_A, linear_combination_a);
  }
  #[inline]
  pub fn add_linear_combination_b(&mut self, linear_combination_b: flatbuffers::WIPOffset<Variables<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Variables>>(BilinearConstraint::VT_LINEAR_COMBINATION_B, linear_combination_b);
  }
  #[inline]
  pub fn add_linear_combination_c(&mut self, linear_combination_c: flatbuffers::WIPOffset<Variables<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Variables>>(BilinearConstraint::VT_LINEAR_COMBINATION_C, linear_combination_c);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BilinearConstraintBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BilinearConstraintBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BilinearConstraint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BilinearConstraint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BilinearConstraint");
      ds.field("linear_combination_a", &self.linear_combination_a());
      ds.field("linear_combination_b", &self.linear_combination_b());
      ds.field("linear_combination_c", &self.linear_combination_c());
      ds.finish()
  }
}
pub enum VariablesOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A description of multiple variables.
///
/// - Each variable is identified by a numerical ID.
/// - Each variable can be assigned a concrete value.
/// - In `CircuitHeader.instance_variables`, the IDs indicate which variables are
///   meant to be shared as inputs or outputs of a sub-circuit.
/// - During witness generation, the values form the assignment to the variables.
/// - In `BilinearConstraint` linear combinations, the values are the coefficients
///   applied to variables in a linear combination.
pub struct Variables<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Variables<'a> {
  type Inner = Variables<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Variables<'a> {
  pub const VT_VARIABLE_IDS: flatbuffers::VOffsetT = 4;
  pub const VT_VALUES: flatbuffers::VOffsetT = 6;
  pub const VT_INFO: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Variables { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args VariablesArgs<'args>
  ) -> flatbuffers::WIPOffset<Variables<'bldr>> {
    let mut builder = VariablesBuilder::new(_fbb);
    if let Some(x) = args.info { builder.add_info(x); }
    if let Some(x) = args.values { builder.add_values(x); }
    if let Some(x) = args.variable_ids { builder.add_variable_ids(x); }
    builder.finish()
  }


  /// The IDs of the variables.
  ///
  /// - IDs must be unique within a constraint system.
  /// - The ID 0 always represents the constant variable one.
  #[inline]
  pub fn variable_ids(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(Variables::VT_VARIABLE_IDS, None)}
  }
  /// Optional: values assigned to variables.
  ///
  /// - Values are finite field elements as defined by `header.field_maximum`.
  /// - Elements are represented in canonical little-endian form.
  /// - Elements appear in the same order as variable_ids.
  /// - Multiple elements are concatenated in a single byte array.
  /// - The element representation may be truncated and its size shorter
  ///   than `header.field_maximum`. Truncated bytes are treated as zeros.
  /// - The size of an element representation is determined by:
  ///
  ///     element size = values.length / variable_ids.length
  #[inline]
  pub fn values(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Variables::VT_VALUES, None)}
  }
  /// Optional: Any complementary info that may be useful to the recipient.
  ///
  /// Example: human-readable names.
  /// Example: custom variable typing information (`is_bit`, ...).
  /// Example: a Merkle authentication path in some custom format.
  #[inline]
  pub fn info(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue>>>>(Variables::VT_INFO, None)}
  }
}

impl flatbuffers::Verifiable for Variables<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("variable_ids", Self::VT_VARIABLE_IDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("values", Self::VT_VALUES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValue>>>>("info", Self::VT_INFO, false)?
     .finish();
    Ok(())
  }
}
pub struct VariablesArgs<'a> {
    pub variable_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub info: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>,
}
impl<'a> Default for VariablesArgs<'a> {
  #[inline]
  fn default() -> Self {
    VariablesArgs {
      variable_ids: None,
      values: None,
      info: None,
    }
  }
}

pub struct VariablesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VariablesBuilder<'a, 'b> {
  #[inline]
  pub fn add_variable_ids(&mut self, variable_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Variables::VT_VARIABLE_IDS, variable_ids);
  }
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Variables::VT_VALUES, values);
  }
  #[inline]
  pub fn add_info(&mut self, info: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Variables::VT_INFO, info);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VariablesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VariablesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Variables<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Variables<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Variables");
      ds.field("variable_ids", &self.variable_ids());
      ds.field("values", &self.values());
      ds.field("info", &self.info());
      ds.finish()
  }
}
pub enum KeyValueOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Generic key-value for custom attributes.
/// The key must be a string.
/// The value can be one of several types.
pub struct KeyValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KeyValue<'a> {
  type Inner = KeyValue<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KeyValue<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_DATA: flatbuffers::VOffsetT = 6;
  pub const VT_TEXT: flatbuffers::VOffsetT = 8;
  pub const VT_NUMBER: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KeyValue { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args KeyValueArgs<'args>
  ) -> flatbuffers::WIPOffset<KeyValue<'bldr>> {
    let mut builder = KeyValueBuilder::new(_fbb);
    builder.add_number(args.number);
    if let Some(x) = args.text { builder.add_text(x); }
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KeyValue::VT_KEY, None)}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(KeyValue::VT_DATA, None)}
  }
  #[inline]
  pub fn text(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KeyValue::VT_TEXT, None)}
  }
  #[inline]
  pub fn number(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(KeyValue::VT_NUMBER, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for KeyValue<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, false)?
     .visit_field::<i64>("number", Self::VT_NUMBER, false)?
     .finish();
    Ok(())
  }
}
pub struct KeyValueArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub number: i64,
}
impl<'a> Default for KeyValueArgs<'a> {
  #[inline]
  fn default() -> Self {
    KeyValueArgs {
      key: None,
      data: None,
      text: None,
      number: 0,
    }
  }
}

pub struct KeyValueBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> KeyValueBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_KEY, key);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_DATA, data);
  }
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_TEXT, text);
  }
  #[inline]
  pub fn add_number(&mut self, number: i64) {
    self.fbb_.push_slot::<i64>(KeyValue::VT_NUMBER, number, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> KeyValueBuilder<'a, 'b> {
    let start = _fbb.start_table();
    KeyValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KeyValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KeyValue<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KeyValue");
      ds.field("key", &self.key());
      ds.field("data", &self.data());
      ds.field("text", &self.text());
      ds.field("number", &self.number());
      ds.finish()
  }
}
pub enum RootOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Root<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Root<'a> {
  type Inner = Root<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Root<'a> {
  pub const VT_MESSAGE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Root { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RootArgs
  ) -> flatbuffers::WIPOffset<Root<'bldr>> {
    let mut builder = RootBuilder::new(_fbb);
    if let Some(x) = args.message { builder.add_message(x); }
    builder.add_message_type(args.message_type);
    builder.finish()
  }


  #[inline]
  pub fn message_type(&self) -> Message {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Message>(Root::VT_MESSAGE_TYPE, Some(Message::NONE)).unwrap()}
  }
  #[inline]
  pub fn message(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Root::VT_MESSAGE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_circuit_header(&self) -> Option<CircuitHeader<'a>> {
    if self.message_type() == Message::CircuitHeader {
      eprintln!("{:?}", self.message_type());
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CircuitHeader::init_from_table(t) }
     })
    } else {
      eprintln!("{:?}", self.message_type());
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_constraint_system(&self) -> Option<ConstraintSystem<'a>> {
    if self.message_type() == Message::ConstraintSystem {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ConstraintSystem::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_witness(&self) -> Option<Witness<'a>> {
    if self.message_type() == Message::Witness {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Witness::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_command(&self) -> Option<Command<'a>> {
    if self.message_type() == Message::Command {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Command::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Root<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<Message, _>("message_type", Self::VT_MESSAGE_TYPE, "message", Self::VT_MESSAGE, false, |key, v, pos| {
        match key {
          Message::CircuitHeader => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CircuitHeader>>("Message::CircuitHeader", pos),
          Message::ConstraintSystem => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConstraintSystem>>("Message::ConstraintSystem", pos),
          Message::Witness => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Witness>>("Message::Witness", pos),
          Message::Command => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Command>>("Message::Command", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct RootArgs {
    pub message_type: Message,
    pub message: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RootArgs {
  #[inline]
  fn default() -> Self {
    RootArgs {
      message_type: Message::NONE,
      message: None,
    }
  }
}

pub struct RootBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RootBuilder<'a, 'b> {
  #[inline]
  pub fn add_message_type(&mut self, message_type: Message) {
    self.fbb_.push_slot::<Message>(Root::VT_MESSAGE_TYPE, message_type, Message::NONE);
  }
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Root::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RootBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RootBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Root<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Root<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Root");
      ds.field("message_type", &self.message_type());
      match self.message_type() {
        Message::CircuitHeader => {
          if let Some(x) = self.message_as_circuit_header() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::ConstraintSystem => {
          if let Some(x) = self.message_as_constraint_system() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::Witness => {
          if let Some(x) = self.message_as_witness() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::Command => {
          if let Some(x) = self.message_as_command() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("message", &x)
        },
      };
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Root`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_root_unchecked`.
pub fn root_as_root(buf: &[u8]) -> Result<Root, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Root>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Root` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_root_unchecked`.
pub fn size_prefixed_root_as_root(buf: &[u8]) -> Result<Root, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Root>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Root` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_root_unchecked`.
pub fn root_as_root_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Root<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Root<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Root` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_root_unchecked`.
pub fn size_prefixed_root_as_root_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Root<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Root<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Root and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Root`.
pub unsafe fn root_as_root_unchecked(buf: &[u8]) -> Root {
  flatbuffers::root_unchecked::<Root>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Root and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Root`.
pub unsafe fn size_prefixed_root_as_root_unchecked(buf: &[u8]) -> Root {
  flatbuffers::size_prefixed_root_unchecked::<Root>(buf)
}
pub const ROOT_IDENTIFIER: &str = "zkif";

#[inline]
pub fn root_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ROOT_IDENTIFIER, false)
}

#[inline]
pub fn root_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ROOT_IDENTIFIER, true)
}

pub const ROOT_EXTENSION: &str = "zkif";

#[inline]
pub fn finish_root_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Root<'a>>) {
  fbb.finish(root, Some(ROOT_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_root_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Root<'a>>) {
  fbb.finish_size_prefixed(root, Some(ROOT_IDENTIFIER));
}
}  // pub mod zkinterface

